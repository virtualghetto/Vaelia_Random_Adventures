#textdomain wesnoth-Vaelia_Random_Adventures

# The macros in this file handle the setup of the next scenario.
# This includes specifying the next level, and picking the next
# map, the enemy faction, and what gold and income levels are to
# be used for each side.

#define VRA_URM_FETCH_NEXT_MAP
    # As cl doesn't work right in this add-on,
    # set_var level= will allow selecting of level
    [if]
        {VARIABLE_CONDITIONAL vra.level not_equals $null}
        [then]
            {VARIABLE temp $vra.level}
        [/then]
    [/if]

    # This section insures that no map is repeated during the campaign
    # After a map is chosen, it is removed from the array
    # set_var map= will allow selecting of map
    # var is cleared in {VRA_RC_NEXT_SCENARIO}

    # check if map list has entries
    [foreach]
        array=vra.urm_map_choice.list
        variable=this_list
        [do]
            [if]
                {VARIABLE_CONDITIONAL this_list.map not_equals $null}
                [then]
                    {VARIABLE list_has_entries yes}
                    [break]
                    [/break]
                [/then]
            [/if]
        [/do]
    [/foreach]
    # if map list is empty, fill it.
    # It is vra.urm_map_choice.list so that it is
    # easier to read in the :inspect listing
    [if]
        {VARIABLE_CONDITIONAL list_has_entries not_equals yes}
        [then]

		{VARIABLE list "Archipelago,Barren,Cave,Citadel,Desert,Flood,Forest,Fracture,Frozen,Island,Jungle,Lava,Marsh,Mountains,Ocean,River,Vale,Volcano,Wastes,Winter"}
            [set_variables]
                name=vra.urm_map_choice.list
                mode=replace
                [split]
                    list=$list
                    key=map
                    separator=,
                    remove_empty=yes
                [/split]
            [/set_variables]
            {CLEAR_VARIABLE list}
        [/then]
    [/if]
    {CLEAR_VARIABLE list_has_entries}
    [if]
        {VARIABLE_CONDITIONAL vra.map equals $null}
        [then]
            # randomly choose a map
            [set_variable]
                name=map_list
                [join]
                    variable=vra.urm_map_choice.list
                    key=map
                    separator=,
                    remove_empty=yes
                [/join]
            [/set_variable]
            {VARIABLE_OP vra.map rand $map_list}
            {CLEAR_VARIABLE map_list}
        [/then]
    [/if]
    {LOOKUP_INDEX vra.urm_map_choice.list map $vra.map index}
    {CLEAR_VARIABLE vra.urm_map_choice.list[$index].map}
    {CLEAR_VARIABLE index}
    # Now that everything is in place, assemble the next scenario id
    {VARIABLE vra.next_scenario ("0$temp|_urm_$vra.map|")}
    {CLEAR_VARIABLE temp}
#enddef

#define VRA_CAVE_FETCH_NEXT_MAP

    # This section insures that no map is repeated during the campaign
    # After a map is chosen, it is removed from the array
    # set_var map= will allow selecting of map
    # var is cleared in {RC_NEXT_SCENARIO}

    [if]
        {VARIABLE_CONDITIONAL vra.level not_equals $null}
        [then]
            {VARIABLE temp $vra.level}
        [/then]
    [/if]

    # check if map list has entries
    [foreach]
        array=vra.cave_map_choice.list
        variable=this_list
        [do]
            [if]
                {VARIABLE_CONDITIONAL this_list.map not_equals $null}
                [then]
                    {VARIABLE list_has_entries yes}
                    [break]
                    [/break]
                [/then]
            [/if]
        [/do]
    [/foreach]
    # if map list is empty, fill it.
    # It is vra.cave_map_choice.list so that it is
    # easier to read in the :inspect listing
    [if]
        {VARIABLE_CONDITIONAL list_has_entries not_equals yes}
        [then]
            {VARIABLE list "Cave0,Cave1,Cave2,Underground0"}
            [set_variables]
                name=vra.cave_map_choice.list
                mode=replace
                [split]
                    list=$list
                    key=map
                    separator=,
                    remove_empty=yes
                [/split]
            [/set_variables]
            {CLEAR_VARIABLE list}
        [/then]
    [/if]
    {CLEAR_VARIABLE list_has_entries}
    [if]
        {VARIABLE_CONDITIONAL vra.map equals $null}
        [then]
            # randomly choose a map
            [set_variable]
                name=map_list
                [join]
                    variable=vra.cave_map_choice.list
                    key=map
                    separator=,
                    remove_empty=yes
                [/join]
            [/set_variable]
            {VARIABLE_OP vra.map rand $map_list}
            {CLEAR_VARIABLE map_list}
        [/then]
    [/if]
    {LOOKUP_INDEX vra.cave_map_choice.list map $vra.map index}
    {CLEAR_VARIABLE vra.cave_map_choice.list[$index].map}
    {CLEAR_VARIABLE index}
    {VARIABLE vra.next_scenario ("0$temp|_vra_$vra.map|")}
    {CLEAR_VARIABLE temp}
#enddef

#define VRA_DESERT_FETCH_NEXT_MAP

    # This section insures that no map is repeated during the campaign
    # After a map is chosen, it is removed from the array
    # set_var map= will allow selecting of map
    # var is cleared in {RC_NEXT_SCENARIO}

    [if]
        {VARIABLE_CONDITIONAL vra.level not_equals $null}
        [then]
            {VARIABLE temp $vra.level}
        [/then]
    [/if]

    # check if map list has entries
    [foreach]
        array=vra.desert_map_choice.list
        variable=this_list
        [do]
            [if]
                {VARIABLE_CONDITIONAL this_list.map not_equals $null}
                [then]
                    {VARIABLE list_has_entries yes}
                    [break]
                    [/break]
                [/then]
            [/if]
        [/do]
    [/foreach]
    # if map list is empty, fill it.
    # It is vra.desert_map_choice.list so that it is
    # easier to read in the :inspect listing
    [if]
        {VARIABLE_CONDITIONAL list_has_entries not_equals yes}
        [then]
            {VARIABLE list "Desert0,Desert1"}
            [set_variables]
                name=vra.desert_map_choice.list
                mode=replace
                [split]
                    list=$list
                    key=map
                    separator=,
                    remove_empty=yes
                [/split]
            [/set_variables]
            {CLEAR_VARIABLE list}
        [/then]
    [/if]
    {CLEAR_VARIABLE list_has_entries}
    [if]
        {VARIABLE_CONDITIONAL vra.map equals $null}
        [then]
            # randomly choose a map
            [set_variable]
                name=map_list
                [join]
                    variable=vra.desert_map_choice.list
                    key=map
                    separator=,
                    remove_empty=yes
                [/join]
            [/set_variable]
            {VARIABLE_OP vra.map rand $map_list}
            {CLEAR_VARIABLE map_list}
        [/then]
    [/if]
    {LOOKUP_INDEX vra.desert_map_choice.list map $vra.map index}
    {CLEAR_VARIABLE vra.desert_map_choice.list[$index].map}
    {CLEAR_VARIABLE index}
    {VARIABLE vra.next_scenario ("0$temp|_vra_$vra.map|")}
    {CLEAR_VARIABLE temp}
#enddef

#define VRA_MARSH_FETCH_NEXT_MAP

    # This section insures that no map is repeated during the campaign
    # After a map is chosen, it is removed from the array
    # set_var map= will allow selecting of map
    # var is cleared in {RC_NEXT_SCENARIO}

    [if]
        {VARIABLE_CONDITIONAL vra.level not_equals $null}
        [then]
            {VARIABLE temp $vra.level}
        [/then]
    [/if]

    # check if map list has entries
    [foreach]
        array=vra.marsh_map_choice.list
        variable=this_list
        [do]
            [if]
                {VARIABLE_CONDITIONAL this_list.map not_equals $null}
                [then]
                    {VARIABLE list_has_entries yes}
                    [break]
                    [/break]
                [/then]
            [/if]
        [/do]
    [/foreach]
    # if map list is empty, fill it.
    # It is vra.marsh_map_choice.list so that it is
    # easier to read in the :inspect listing
    [if]
        {VARIABLE_CONDITIONAL list_has_entries not_equals yes}
        [then]
            {VARIABLE list "Marsh0,Marsh1"}
            [set_variables]
                name=vra.marsh_map_choice.list
                mode=replace
                [split]
                    list=$list
                    key=map
                    separator=,
                    remove_empty=yes
                [/split]
            [/set_variables]
            {CLEAR_VARIABLE list}
        [/then]
    [/if]
    {CLEAR_VARIABLE list_has_entries}
    [if]
        {VARIABLE_CONDITIONAL vra.map equals $null}
        [then]
            # randomly choose a map
            [set_variable]
                name=map_list
                [join]
                    variable=vra.marsh_map_choice.list
                    key=map
                    separator=,
                    remove_empty=yes
                [/join]
            [/set_variable]
            {VARIABLE_OP vra.map rand $map_list}
            {CLEAR_VARIABLE map_list}
        [/then]
    [/if]
    {LOOKUP_INDEX vra.marsh_map_choice.list map $vra.map index}
    {CLEAR_VARIABLE vra.marsh_map_choice.list[$index].map}
    {CLEAR_VARIABLE index}
    {VARIABLE vra.next_scenario ("0$temp|_vra_$vra.map|")}
    {CLEAR_VARIABLE temp}
#enddef

#define VRA_WINTER_FETCH_NEXT_MAP

    # This section insures that no map is repeated during the campaign
    # After a map is chosen, it is removed from the array
    # set_var map= will allow selecting of map
    # var is cleared in {RC_NEXT_SCENARIO}

    [if]
        {VARIABLE_CONDITIONAL vra.level not_equals $null}
        [then]
            {VARIABLE temp $vra.level}
        [/then]
    [/if]

    # check if map list has entries
    [foreach]
        array=vra.winter_map_choice.list
        variable=this_list
        [do]
            [if]
                {VARIABLE_CONDITIONAL this_list.map not_equals $null}
                [then]
                    {VARIABLE list_has_entries yes}
                    [break]
                    [/break]
                [/then]
            [/if]
        [/do]
    [/foreach]
    # if map list is empty, fill it.
    # It is vra.winter_map_choice.list so that it is
    # easier to read in the :inspect listing
    [if]
        {VARIABLE_CONDITIONAL list_has_entries not_equals yes}
        [then]
            {VARIABLE list "Winter0,Winter1,Winter2"}
            [set_variables]
                name=vra.winter_map_choice.list
                mode=replace
                [split]
                    list=$list
                    key=map
                    separator=,
                    remove_empty=yes
                [/split]
            [/set_variables]
            {CLEAR_VARIABLE list}
        [/then]
    [/if]
    {CLEAR_VARIABLE list_has_entries}
    [if]
        {VARIABLE_CONDITIONAL vra.map equals $null}
        [then]
            # randomly choose a map
            [set_variable]
                name=map_list
                [join]
                    variable=vra.winter_map_choice.list
                    key=map
                    separator=,
                    remove_empty=yes
                [/join]
            [/set_variable]
            {VARIABLE_OP vra.map rand $map_list}
            {CLEAR_VARIABLE map_list}
        [/then]
    [/if]
    {LOOKUP_INDEX vra.winter_map_choice.list map $vra.map index}
    {CLEAR_VARIABLE vra.winter_map_choice.list[$index].map}
    {CLEAR_VARIABLE index}
    {VARIABLE vra.next_scenario ("0$temp|_vra_$vra.map|")}
    {CLEAR_VARIABLE temp}
#enddef

#define VRA_PLAIN_FETCH_NEXT_MAP

    # This section insures that no map is repeated during the campaign
    # After a map is chosen, it is removed from the array
    # set_var map= will allow selecting of map
    # var is cleared in {RC_NEXT_SCENARIO}

    [if]
        {VARIABLE_CONDITIONAL vra.level not_equals $null}
        [then]
            {VARIABLE temp $vra.level}
        [/then]
    [/if]

    # check if map list has entries
    [foreach]
        array=vra.plain_map_choice.list
        variable=this_list
        [do]
            [if]
                {VARIABLE_CONDITIONAL this_list.map not_equals $null}
                [then]
                    {VARIABLE list_has_entries yes}
                    [break]
                    [/break]
                [/then]
            [/if]
        [/do]
    [/foreach]
    # if map list is empty, fill it.
    # It is vra.plain_map_choice.list so that it is
    # easier to read in the :inspect listing
    [if]
        {VARIABLE_CONDITIONAL list_has_entries not_equals yes}
        [then]
            {VARIABLE list "Plain0,Plain1"}
            [set_variables]
                name=vra.plain_map_choice.list
                mode=replace
                [split]
                    list=$list
                    key=map
                    separator=,
                    remove_empty=yes
                [/split]
            [/set_variables]
            {CLEAR_VARIABLE list}
        [/then]
    [/if]
    {CLEAR_VARIABLE list_has_entries}
    [if]
        {VARIABLE_CONDITIONAL vra.map equals $null}
        [then]
            # randomly choose a map
            [set_variable]
                name=map_list
                [join]
                    variable=vra.plain_map_choice.list
                    key=map
                    separator=,
                    remove_empty=yes
                [/join]
            [/set_variable]
            {VARIABLE_OP vra.map rand $map_list}
            {CLEAR_VARIABLE map_list}
        [/then]
    [/if]
    {LOOKUP_INDEX vra.plain_map_choice.list map $vra.map index}
    {CLEAR_VARIABLE vra.plain_map_choice.list[$index].map}
    {CLEAR_VARIABLE index}
    {VARIABLE vra.next_scenario ("0$temp|_vra_$vra.map|")}
    {CLEAR_VARIABLE temp}
#enddef

#define VRA_RC_CHOOSE_ENEMY
    # This section insures that no opponent is repeated during
    # the campaign until the list runs out of choices.
    # After an opponent is chosen, it is removed from the array
    # set_var enemy= will allow selecting of enemy
    # var is cleared in {RC_SIDE_ENEMY} in _sides.cfg

    # check if enemy list has entries
    [foreach]
        array=vra.enemy_choice.list
        variable=this_list
        [do]
            [if]
                {VARIABLE_CONDITIONAL this_list.enemy not_equals $null}
                [then]
                    {VARIABLE list_has_entries yes}
                    [break]
                    [/break]
                [/then]
            [/if]
        [/do]
    [/foreach]
    # if enemy list is empty, fill it.
    # It is vra.enemy_choice.list so that it is
    # easier to read in the :inspect listing
    [if]
        {VARIABLE_CONDITIONAL list_has_entries not_equals yes}
        [then]
            {VARIABLE list ({VRA_ENEMY_FACTIONS})}
            [set_variables]
                name=vra.enemy_choice.list
                mode=replace
                [split]
                    list=$list
                    key=enemy
                    separator=,
                    remove_empty=yes
                [/split]
            [/set_variables]
            {CLEAR_VARIABLE list}
        [/then]
    [/if]
    {CLEAR_VARIABLE list_has_entries}
    [if]
        {VARIABLE_CONDITIONAL vra.enemy equals $null}
        [then]
            # randomly choose a faction from the era
            # This section insures that no faction is repeated during the campaign until all have been chosen.
            # After a faction is chosen, it is removed from the array
            [set_variable]
                name=enemy_list
                [join]
                    variable=vra.enemy_choice.list
                    key=enemy
                    separator=,
                    remove_empty=yes
                [/join]
            [/set_variable]
            {VARIABLE_OP vra.enemy rand $enemy_list}
            {CLEAR_VARIABLE enemy_list}
        [/then]
    [/if]
    {LOOKUP_INDEX vra.enemy_choice.list enemy $vra.enemy index}
    {CLEAR_VARIABLE vra.enemy_choice.list[$index].enemy}
    {CLEAR_VARIABLE index}
#enddef

#define VRA_RESTATE_ENEMY VRA_TYPE
[set_variables]
	name=vra.enemy_choice.list
	mode=append
	[value]
		enemy={VRA_TYPE}
	[/value]
[/set_variables]
#enddef

#define RESTORE_SIDE_TYPE SIDE
[store_side]
	variable=side_store
	side={SIDE}
[/store_side]
{VRA_RESTATE_ENEMY $side_store.side_name}
{CLEAR_VARIABLE side_store}
#enddef


#define VRA_RAND_CHOICE NUM
    [foreach]
        array=random_choice_arr.list
        variable=this_list
        [do]
            [if]
                {VARIABLE_CONDITIONAL this_list.choice not_equals $null}
                [then]
                    {VARIABLE list_has_entries yes}
                    [break]
                    [/break]
                [/then]
            [/if]
        [/do]
    [/foreach]

    [if]
        {VARIABLE_CONDITIONAL list_has_entries not_equals yes}
        [then]
            {VARIABLE list ({NUM})}
            [set_variables]
                name=random_choice_arr.list
                mode=replace
                [split]
                    list=$list
                    key=choice
                    separator=,
                    remove_empty=yes
                [/split]
            [/set_variables]
            {CLEAR_VARIABLE list}
        [/then]
    [/if]
    {CLEAR_VARIABLE list_has_entries}
    [if]
        {VARIABLE_CONDITIONAL random_choice equals $null}
        [then]
            # randomly choose a choice
            [set_variable]
                name=choice_list
                [join]
                    variable=random_choice_arr.list
                    key=choice
                    separator=,
                    remove_empty=yes
                [/join]
            [/set_variable]
            {VARIABLE_OP random_choice rand $choice_list}
            {CLEAR_VARIABLE choice_list}
        [/then]
    [/if]
    {LOOKUP_INDEX random_choice_arr.list choice $random_choice index}
    {CLEAR_VARIABLE random_choice_arr.list[$index].choice}
    {CLEAR_VARIABLE index}
#enddef
